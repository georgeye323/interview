### 1、OSI的七层模型分别是？各自的功能是什么

***

​	**--简要概述--** 

 1. 物理层：底层数据传输，如网线；网卡标准

 2. 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡 MAC地址

 3. 网路层：定义IP编码，定义路由功能；如不同设备的数据转发；

 4. 传输层：端到端传输数据的基本功能；如TCP、UDP

 5. 会话层：控制应用程序之间的会话能力；如不同软件数据分发给不同软件；

 6. 表示层：数据格式标识，基本压缩加密功能；

 7. 应用层：各种应用软件，包括web应用。

    **--说明--**

 * 在四层，既传输层数据被称为段(segments)

 * 在三层网路数据被称为包(packages)

 * 两层数据链路层时数据被称为帧(Frames);

 * 一层物理层时数据被称为比特流(Bits);

   **总结**

 * 网络七层模型是一个标准，而非实现。

 * 网络四层模型是一个实现的应用模型。

 * 网络四层模型由七层模型简化合并而来。

***

### 2、为什么需要三次握手？两次不行？

​		三次握手

​		刚开始客户端处于closed的状态，服务端处于listen状态。

		1. 	第一次握手：客户端给服务端发送一个SYN报文，并指明客户端的初始化序列号ISN。此时客户端处于SYN_Send状态。
  		2. 	第二次握手：服务器收到客户端的SYN报文以后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN，同时会把客户端的**ISN+1**作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RECD的状态。
  		3. 	第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当然，也是一样把服务器的**ISN+1**作为AC K的值，表示已经收到了服务端的SYN报文，此时客户端处于established状态。
  		4. 	服务器收到ACK报文之后，也处于established状态，此时，双方建立起了链接

![三次握手详情](E:\george\interview\三次握手详情.png)

---

### 3、为什么需要四次挥手？三次不行？

​	刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于**FIN_WAIT1**状态
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT**状态。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 的状态。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5. 服务端收到ACK报文之后，就处于关闭连接了，处于 COLSED状态

![四次挥手详情](E:\george\interview\四次挥手详情.png)

每个状态所包含的含义：

LISTEN – 侦听来自远方TCP端口的连接请求；

SYN-SENT -在发送连接请求后等待匹配的连接请求；

SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认；

ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；

FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

FIN-WAIT-2 – 从远程TCP等待连接中断请求；

CLOSE-WAIT – 等待从本地用户发来的连接中断请求；

CLOSING -等待远程TCP对连接中断的确认；

LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认；

TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；

CLOSED – 没有任何连接状态；

